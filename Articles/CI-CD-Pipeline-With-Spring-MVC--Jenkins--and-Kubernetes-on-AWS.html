<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>CI/CD Pipeline With Spring MVC, Jenkins, and Kubernetes on AWS</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">CI/CD Pipeline With Spring MVC, Jenkins, and Kubernetes on AWS</h1>
</header>
<section data-field="subtitle" class="p-summary">
These three tools will automate the creation and deployment of a Docker image on AWS.
</section>
<section data-field="body" class="e-content">
<section name="3806" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0005" id="0005" class="graf graf--h3 graf--leading graf--title">CI/CD Pipeline With Spring MVC, Jenkins, and Kubernetes on AWS</h3><figure name="decb" id="decb" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 277px; max-height: 351px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 126.69999999999999%;"></div><img class="graf-image" data-image-id="1*PjBem6k9IirXwQjmxMW0UQ.png" data-width="277" data-height="351" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*PjBem6k9IirXwQjmxMW0UQ.png"></div></figure><h3 name="731f" id="731f" class="graf graf--h3 graf-after--figure">These three tools will automate the creation and deployment of a Docker image on AWS.</h3><p name="e750" id="e750" class="graf graf--p graf-after--h3">The purpose of this post is to show you how to set up a CI/CD pipeline using Jenkins and deploy it to a Kubernetes cluster.</p><p name="a008" id="a008" class="graf graf--p graf-after--p">First, a quick intro to <a href="https://dimuthukasunwp.github.io/Articles/How-To-Apply-CI-CD-For-Spring-Boot.html" data-href="https://dimuthukasunwp.github.io/Articles/How-To-Apply-CI-CD-For-Spring-Boot.html" class="markup--anchor markup--p-anchor" target="_blank">continuous integration (CI) and continuous deployment (CD)</a>. CI is the process of integrating code changes to a shared code repository. Steps include compiling, validating, unit testing, and integration testing. It’s good practice to commit small logically correct changes frequently rather than a big change infrequently.</p><p name="7d97" id="7d97" class="graf graf--p graf-after--p">The next step is continuous deployment. The integrated code needs to be deployed to servers in the assigned environment. For example, if you are handling a colossal system like Facebook, you wouldn’t go into thousands of servers manually to deploy your code. You need an automated system to do that for you.</p><p name="d698" id="d698" class="graf graf--p graf-after--p">Ours is a Spring MVC project which gets deployed to a Tomcat server as a WAR file. We will create a Docker image of the Tomcat server with the WAR file in it and push it to a Docker registry. Then Kubernetes would pull that image and deploy our application giving us an endpoint to query to.</p><figure name="a570" id="a570" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 400px; max-height: 383px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 95.8%;"></div><img class="graf-image" data-image-id="1*8lwe-vf5FpN1y7Fyy9EtsA.png" data-width="400" data-height="383" src="https://cdn-images-1.medium.com/max/800/1*8lwe-vf5FpN1y7Fyy9EtsA.png"></div></figure><h3 name="bc3c" id="bc3c" class="graf graf--h3 graf-after--figure">Setting Up Dockerfile</h3><p name="b617" id="b617" class="graf graf--p graf-after--h3">Docker is a containerization service. If you are not familiar with <a href="https://dzone.com/articles/containers-101-what-do-you-need-to-know" data-href="https://dzone.com/articles/containers-101-what-do-you-need-to-know" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">containers</a> and the difference between containers and virtual machines <a href="https://www.youtube.com/watch?v=L1ie8negCjc" data-href="https://www.youtube.com/watch?v=L1ie8negCjc" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here’s a video</a> to get started.</p><p name="0e0b" id="0e0b" class="graf graf--p graf-after--p">Once you’ve created a Docker image, it needs to be stored and updated somewhere. Some options are <a href="https://hub.docker.com/" data-href="https://hub.docker.com/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Docker Hub</a>, which is a hosted registry, or <a href="https://docs.docker.com/registry/" data-href="https://docs.docker.com/registry/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Docker registry</a>, which is open source and free. In this example, we will use a Docker registry.</p><p name="68e8" id="68e8" class="graf graf--p graf-after--p">First, we’ll pull a Tomcat image and customize it. By customizing I mean that if you want to add any libraries to the lib folder in Tomcat then you need to pull the image, run Tomcat and copy all the libraries into it, then tag that new image and push it to Docker registry (you can pull the Tomcat image from <a href="https://hub.docker.com/_/tomcat" data-href="https://hub.docker.com/_/tomcat" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>).</p><p name="1303" id="1303" class="graf graf--p graf-after--p">Here’s the process. Say we want to pull tomcat:9-jre11. Run the below code to pull the Tomcat image.</p><pre name="37b6" id="37b6" class="graf graf--pre graf-after--p">docker run -d -p 8080:8080 tomcat:9-jre11 (note: -d is to run container in the background and -p is for port to use)</pre><p name="2572" id="2572" class="graf graf--p graf-after--pre">Next, to copy the provided libraries from local tomcat to the Tomcat image use the <code class="markup--code markup--p-code">Docker cp</code> command</p><pre name="a5e6" id="a5e6" class="graf graf--pre graf-after--p">docker cp folderName containerId:usr/local/tomcat</pre><p name="8f7d" id="8f7d" class="graf graf--p graf-after--pre">Next, use <code class="markup--code markup--p-code">docker commit</code> to save the changes and create a new tag for the image.</p><pre name="5254" id="5254" class="graf graf--pre graf-after--p">docker commit containerId tomcat:newTomcatCustom</pre><p name="b8ec" id="b8ec" class="graf graf--p graf-after--pre">Each time you make any changes, commit using the same tag that you initially used.</p><p name="57de" id="57de" class="graf graf--p graf-after--p">To go inside the container and make changes, use this command <code class="markup--code markup--p-code">docker exec -it containerId bash</code> after running the image and then commit after making changes.</p><p name="5653" id="5653" class="graf graf--p graf-after--p">So now our custom Tomcat is ready. Let’s setup Dockerfile which would deploy the video war file in the Tomcat image.</p><p name="43e3" id="43e3" class="graf graf--p graf-after--p">Dockerfile content:</p><pre name="bf47" id="bf47" class="graf graf--pre graf-after--p">FROM tomcat:newTomcatCustom</pre><pre name="5e7b" id="5e7b" class="graf graf--pre graf-after--pre">COPY /path/to/filename.war /usr/local/tomcat/webapps/filename.war</pre><p name="79c7" id="79c7" class="graf graf--p graf-after--pre">Build and run this Dockerfile, and your Tomcat server will be up with the war file deployed.</p><figure name="c293" id="c293" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 494px; max-height: 502px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 101.6%;"></div><img class="graf-image" data-image-id="1*6ydkKMsUSetCrCkH9SHOiw.png" data-width="494" data-height="502" src="https://cdn-images-1.medium.com/max/800/1*6ydkKMsUSetCrCkH9SHOiw.png"></div></figure><h3 name="cf05" id="cf05" class="graf graf--h3 graf-after--figure">Pushing to Docker Registry</h3><p name="daa7" id="daa7" class="graf graf--p graf-after--h3">To push the Docker image to the Docker registry, set up a Docker registry and then push the Docker image using the below commands.</p><pre name="5cca" id="5cca" class="graf graf--pre graf-after--p">docker tag containerId server-ip-registry:port/tag</pre><pre name="b5be" id="b5be" class="graf graf--pre graf-after--pre">docker push server-ip-registry:port/tag</pre><p name="0a7b" id="0a7b" class="graf graf--p graf-after--pre">If the Docker registry is not using HTTPS, you may get an insecure repository error. To solve for this, either make it HTTPS and add the certificate in Docker or create a file at /etc/docker called daemon.json and add the following JSON to it. This JSON would indicate the insecure registry (non https) where the Docker image is being pushed.</p><pre name="0d7b" id="0d7b" class="graf graf--pre graf-after--p">{</pre><pre name="2dcf" id="2dcf" class="graf graf--pre graf-after--pre">&quot;insecure-registries&quot; : [ &quot;registryLink:port&quot; ]</pre><pre name="8109" id="8109" class="graf graf--pre graf-after--pre">}</pre><h3 name="573e" id="573e" class="graf graf--h3 graf-after--pre">Amazon EKS</h3><p name="96ef" id="96ef" class="graf graf--p graf-after--h3">We’ve created an image and pushed it to a common accessible point. Now we’ll set up a Kubernetes cluster on AWS EKS. In production, one Docker running server would not be sufficient to take the load of all users so you need to set up a cluster with multiple servers having Docker images up and running. All of this is handled by Kubernetes.</p><p name="e8b0" id="e8b0" class="graf graf--p graf-after--p">If you are not familiar with Kubernetes, take a look at the <a href="https://medium.com/faun/kubernetes-architecture-85ad2999882a" data-href="https://medium.com/faun/kubernetes-architecture-85ad2999882a" class="markup--anchor markup--p-anchor" target="_blank">Kubernetes architecture</a> and its various components like replication controller, pods, services, replica sets, deployments etc. AWS has a well documented page <a href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html" data-href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started-console.html" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">here</a>.</p><p name="cd6e" id="cd6e" class="graf graf--p graf-after--p">After your cluster is up and running the next step is to create a replication controller and a service file. The replication controller would take care of the number of pods and their replicas that are to be maintained and the service file will give us the IP address to connect to our Spring REST APIs. Each pod in the Kubernetes cluster has its own IP address which is known to the services, and the services provide an abstraction to decouple the frontend and the backend.</p><h3 name="f63b" id="f63b" class="graf graf--h3 graf-after--p">Replication Controller and Services</h3><p name="24c7" id="24c7" class="graf graf--p graf-after--h3">In this section, we are going to create a replication controller and a service file for deployment purposes. You could create a separate master and slave for both but a better alternative is to create a deployment file, which has advantages over a replication controller. But once you know the basics, you can use any approach.</p><p name="3b31" id="3b31" class="graf graf--p graf-after--p">Our replication controller would be a JSON file…but you can also create a YAML file.</p><pre name="08e6" id="08e6" class="graf graf--pre graf-after--p">kind: ReplicationController</pre><pre name="b059" id="b059" class="graf graf--pre graf-after--pre">apiVersion: v1</pre><pre name="0c93" id="0c93" class="graf graf--pre graf-after--pre">metadata:</pre><pre name="31f7" id="31f7" class="graf graf--pre graf-after--pre">name: videobook-controller-1</pre><pre name="2acf" id="2acf" class="graf graf--pre graf-after--pre">labels:</pre><pre name="1764" id="1764" class="graf graf--pre graf-after--pre">app: videobook-controller-1</pre><pre name="6bf3" id="6bf3" class="graf graf--pre graf-after--pre">spec:</pre><pre name="846a" id="846a" class="graf graf--pre graf-after--pre">replicas: 3</pre><pre name="b6c7" id="b6c7" class="graf graf--pre graf-after--pre">selector:</pre><pre name="b785" id="b785" class="graf graf--pre graf-after--pre">app: videobook</pre><pre name="d203" id="d203" class="graf graf--pre graf-after--pre">deploy: firstVersion</pre><pre name="330e" id="330e" class="graf graf--pre graf-after--pre">template:</pre><pre name="c65f" id="c65f" class="graf graf--pre graf-after--pre">metadata:</pre><pre name="9bf8" id="9bf8" class="graf graf--pre graf-after--pre">labels:</pre><pre name="fbf1" id="fbf1" class="graf graf--pre graf-after--pre">app: videobook</pre><pre name="8931" id="8931" class="graf graf--pre graf-after--pre">deploy: firstVersion</pre><pre name="a25a" id="a25a" class="graf graf--pre graf-after--pre">spec:</pre><pre name="8de9" id="8de9" class="graf graf--pre graf-after--pre">containers:</pre><pre name="46b9" id="46b9" class="graf graf--pre graf-after--pre">- name: videobook</pre><pre name="43d5" id="43d5" class="graf graf--pre graf-after--pre">image: server-ip:5000/dockerImageName</pre><pre name="5fa1" id="5fa1" class="graf graf--pre graf-after--pre">imagePullPolicy: Always</pre><pre name="6247" id="6247" class="graf graf--pre graf-after--pre">ports:</pre><pre name="1a71" id="1a71" class="graf graf--pre graf-after--pre">- name: http-server</pre><pre name="d44b" id="d44b" class="graf graf--pre graf-after--pre">containerPort: 8080</pre><p name="69ab" id="69ab" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Labels and Selectors:</strong> Labels are used to group while selectors are for uniqueness. For example, if there are multiple replication controllers then labels can denote whether it’s the staging or production environment so changes in the image can be made according to the environment. The replication controller file is self-explanatory. The image consists of the image tag, which was pushed to the Docker registry — here, selectors are useful to uniquely identify the pods and the service file (we’ll talk about this later in the post).</p><p name="e456" id="e456" class="graf graf--p graf-after--p">Now run the command. This is the starting point of your cluster. This command would initiate the controller</p><pre name="efde" id="efde" class="graf graf--pre graf-after--p">kubectl create -f video-controller.yaml</pre><p name="3286" id="3286" class="graf graf--p graf-after--pre">Output: replicationcontroller/videobook-controller-1 created</p><p name="5449" id="5449" class="graf graf--p graf-after--p">To check if the pods are running, run this code:</p><pre name="954a" id="954a" class="graf graf--pre graf-after--p">kubectl describe replicationcontroller/videobook-controller-1</pre><p name="889a" id="889a" class="graf graf--p graf-after--pre">Now let’s deploy the service file:</p><pre name="7bca" id="7bca" class="graf graf--pre graf-after--p">kind: Service</pre><pre name="2647" id="2647" class="graf graf--pre graf-after--pre">apiVersion: v1</pre><pre name="e001" id="e001" class="graf graf--pre graf-after--pre">metadata:</pre><pre name="d113" id="d113" class="graf graf--pre graf-after--pre">name: videobook-servic</pre><pre name="3876" id="3876" class="graf graf--pre graf-after--pre">labels:</pre><pre name="93de" id="93de" class="graf graf--pre graf-after--pre">app: videobook-servic</pre><pre name="b828" id="b828" class="graf graf--pre graf-after--pre">spec:</pre><pre name="181c" id="181c" class="graf graf--pre graf-after--pre">ports:</pre><pre name="3fe4" id="3fe4" class="graf graf--pre graf-after--pre">- port: 8080</pre><pre name="4dae" id="4dae" class="graf graf--pre graf-after--pre">targetPort: http-server</pre><pre name="5e97" id="5e97" class="graf graf--pre graf-after--pre">selector:</pre><pre name="7570" id="7570" class="graf graf--pre graf-after--pre">app: videobook</pre><pre name="b207" id="b207" class="graf graf--pre graf-after--pre">type: LoadBalancer</pre><p name="c524" id="c524" class="graf graf--p graf-after--pre">The only thing to be careful of here is that the app value matches the app value in replication controller (in our case, it’s videobook). This would let the service file know about the pods and would then connect to their IPs.</p><pre name="7c58" id="7c58" class="graf graf--pre graf-after--p">kubectl create -f video-service.yaml</pre><pre name="feda" id="feda" class="graf graf--pre graf-after--pre">kubectl get services</pre><p name="0857" id="0857" class="graf graf--p graf-after--pre">This will give you a link, which will be live after a minute or two. Check port 8080 to test if it’s working for Tomcat.</p><h3 name="c9d3" id="c9d3" class="graf graf--h3 graf-after--p">Rolling Updates</h3><p name="6b93" id="6b93" class="graf graf--p graf-after--h3">Your application is now managed by Kubernetes. The next major part is <a href="https://dzone.com/articles/kubernetes-deployment-strategies" data-href="https://dzone.com/articles/kubernetes-deployment-strategies" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">rolling updates</a>; if your image is updated in the Docker registry, then Kubernetes should deploy it to its pods and update the application backend system. This is achieved by performing rolling updates in Kubernetes.</p><p name="d91a" id="d91a" class="graf graf--p graf-after--p">Kubernetes rolling updates provides the functionality to deploy changes with 0% downtime.</p><p name="072f" id="072f" class="graf graf--p graf-after--p">The rolling update should make sure that the service endpoint is not tampered with because that endpoint would then also be used as the frontend.</p><p name="92f0" id="92f0" class="graf graf--p graf-after--p">For rolling updates, the controller is the configuration file that would be passed. To perform <a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" data-href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">rolling updates</a>, there are certain criteria to be met.</p><ul class="postList"><li name="8c4c" id="8c4c" class="graf graf--li graf-after--p">Specify a different <strong class="markup--strong markup--li-strong">metadata.name</strong> value.</li><li name="958f" id="958f" class="graf graf--li graf-after--li">Overwrite at least one common label in its <strong class="markup--strong markup--li-strong">spec.selector</strong> field.</li><li name="a236" id="a236" class="graf graf--li graf-after--li">Use the same <strong class="markup--strong markup--li-strong">metadata.namespace</strong></li></ul><p name="f245" id="f245" class="graf graf--p graf-after--li">Currently, we have only two YAML files, service and controller files. For rolling updates, at least one field in the selector should change. Let’s say that field is “deploy” and let’s also update the metadata.name field. Since our project doesn’t use the metadata.namespace field, we can ignore those criteria.</p><p name="345e" id="345e" class="graf graf--p graf-after--p">Change the metadata.name (call it videobook-controller-2 ) and the selector.deploy field (call it secondVersion) and save the file. Then run the rolling-update command with the old metadata.name field value</p><pre name="11fa" id="11fa" class="graf graf--pre graf-after--p">kubectl rolling-update videobook-controller-1 -f video-controller.json</pre><p name="7738" id="7738" class="graf graf--p graf-after--pre">This would pull the Docker image and would update each pod without downtime and service endpoint would remain the same</p><h3 name="f8cc" id="f8cc" class="graf graf--h3 graf-after--p">CI/CD Pipeline</h3><p name="68c4" id="68c4" class="graf graf--p graf-after--h3">After the Kubernetes cluster is up and running, the next step to manage updates. Each time code is added/changed is needs to tested, pushed to Docker registry and then pulled by the Kubernetes cluster and deployed. This is all handled by the Jenkins pipeline.</p><p name="dd3e" id="dd3e" class="graf graf--p graf-after--p">Setting up a CI/CD pipeline is easy. First, install Jenkins. Jenkins default will start on port 8080. If you want to change the Jenkins port, go to /var/lib/jenkins and edit the <code class="markup--code markup--p-code">HTTP_PORT</code> field to that port.</p><p name="7796" id="7796" class="graf graf--p graf-after--p">Next, go to the Jenkins link (localhost:8081) and let’s create a Jenkins pipeline. You can also create a freestyle project where you will simply write the commands, but in the pipeline, you can define stages and it’ll look more systematic.</p><p name="bbef" id="bbef" class="graf graf--p graf-after--p">Now choose the pipeline option on the home page. Click on the pipeline tab to write the pipeline script.</p><p name="c109" id="c109" class="graf graf--p graf-after--p">The sample pipeline script is:</p><pre name="e988" id="e988" class="graf graf--pre graf-after--p">def getTimeStamp(){</pre><pre name="f677" id="f677" class="graf graf--pre graf-after--pre">return sh (script: &quot;date +&#39;%Y%m%d%H%M%S%N&#39; | sed &#39;s/[0-9][0-9][0-9][0-9][0-9][0-9]\$//g&#39;&quot;, returnStdout: true);</pre><pre name="3ed4" id="3ed4" class="graf graf--pre graf-after--pre">}</pre><pre name="f047" id="f047" class="graf graf--pre graf-after--pre">node(&#39;master&#39;){</pre><pre name="d7ad" id="d7ad" class="graf graf--pre graf-after--pre">stage(&#39;Init&#39;){</pre><pre name="cb5f" id="cb5f" class="graf graf--pre graf-after--pre">script{</pre><pre name="e6d9" id="e6d9" class="graf graf--pre graf-after--pre">env.TIMESTAMP = getTimeStamp();</pre><pre name="0e9c" id="0e9c" class="graf graf--pre graf-after--pre">env.REGISTRY_LINK = &#39;&lt;IP&gt;:&lt;PORT&gt;/testitkuber&#39;</pre><pre name="82f5" id="82f5" class="graf graf--pre graf-after--pre">}</pre><pre name="6812" id="6812" class="graf graf--pre graf-after--pre">}</pre><pre name="aaf0" id="aaf0" class="graf graf--pre graf-after--pre">stage(&#39;projectInstall&#39;) {</pre><pre name="7ff9" id="7ff9" class="graf graf--pre graf-after--pre">git credentialsId: &#39;829494b2-fb3e-4374-8514-47c89e52633f&#39;, url:&#39;bitbucket_url&#39;</pre><pre name="7a2f" id="7a2f" class="graf graf--pre graf-after--pre">dir(&#39;path/to/the/spring/project&#39;) {</pre><pre name="6282" id="6282" class="graf graf--pre graf-after--pre">sh &#39;’’mvn test’’’</pre><pre name="68ae" id="68ae" class="graf graf--pre graf-after--pre">sh &#39;’’mvn install’’&#39;</pre><pre name="0647" id="0647" class="graf graf--pre graf-after--pre">}</pre><pre name="04ef" id="04ef" class="graf graf--pre graf-after--pre">}</pre><pre name="d3f4" id="d3f4" class="graf graf--pre graf-after--pre">stage(&#39;dockerBuild&#39;) {</pre><pre name="48ae" id="48ae" class="graf graf--pre graf-after--pre">dir(&#39;/path/to/the/spring/project/’) {</pre><pre name="25fa" id="25fa" class="graf graf--pre graf-after--pre">sh &#39;&#39;&#39;</pre><pre name="f4d0" id="f4d0" class="graf graf--pre graf-after--pre">docker build -t ${TIMESTAMP} .</pre><pre name="fd86" id="fd86" class="graf graf--pre graf-after--pre">docker tag ${TIMESTAMP} ${REGISTRY_LINK}</pre><pre name="bb60" id="bb60" class="graf graf--pre graf-after--pre">docker push ${REGISTRY_LINK}</pre><pre name="db47" id="db47" class="graf graf--pre graf-after--pre">&#39;&#39;&#39;</pre><pre name="4ba0" id="4ba0" class="graf graf--pre graf-after--pre">}}</pre><pre name="a768" id="a768" class="graf graf--pre graf-after--pre">stage(rollingUpdates){</pre><pre name="eec1" id="eec1" class="graf graf--pre graf-after--pre">dir(&#39;/path/to/the/kubernetes/files&#39;) {</pre><pre name="ea09" id="ea09" class="graf graf--pre graf-after--pre">sh &#39;&#39;&#39;</pre><pre name="8684" id="8684" class="graf graf--pre graf-after--pre">kubectl rolling-update  video-controller-1 -f video-controller.json</pre><pre name="008b" id="008b" class="graf graf--pre graf-after--pre">&#39;&#39;’</pre><pre name="e300" id="e300" class="graf graf--pre graf-after--pre">}</pre><pre name="10ab" id="10ab" class="graf graf--pre graf-after--pre">}</pre><pre name="a727" id="a727" class="graf graf--pre graf-after--pre">}</pre><p name="6b6b" id="6b6b" class="graf graf--p graf-after--pre">Note the <code class="markup--code markup--p-code">node(‘master’)</code> in the code – this indicates that the server is the master node. It’s compulsory to include this command or you’d get an error. <code class="markup--code markup--p-code">Node</code> specifies <em class="markup--em markup--p-em">where</em> changes will happen; <code class="markup--code markup--p-code">master</code> is the name assigned to it.</p><p name="b77e" id="b77e" class="graf graf--p graf-after--p">Next, click on “Pipeline Syntax” and in the sample step you can enter the operation you need and then type the command, and generate pipeline script.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="c96a" id="c96a" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1168px; max-height: 504px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 43.2%;"></div><img class="graf-image" data-image-id="1*ZmWeax7aWmlemWTG1C-ViA.png" data-width="1168" data-height="504" src="https://cdn-images-1.medium.com/max/1200/1*ZmWeax7aWmlemWTG1C-ViA.png"></div></figure></div><div class="section-inner sectionLayout--insetColumn"><figure name="455c" id="455c" class="graf graf--figure graf-after--figure"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 309px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 44.2%;"></div><img class="graf-image" data-image-id="1*v6nCoUhV9kvUvyi6d5EZXg.png" data-width="1303" data-height="576" src="https://cdn-images-1.medium.com/max/800/1*v6nCoUhV9kvUvyi6d5EZXg.png"></div></figure><h3 name="389c" id="389c" class="graf graf--h3 graf-after--figure">Troubleshooting</h3><ul class="postList"><li name="5ea3" id="5ea3" class="graf graf--li graf-after--h3">Amazon EKS uses the aws-iam-authenticator for authentication purposes and you might need to move the aws-iam-authenticator file to /bin folder if not already present</li><li name="94c2" id="94c2" class="graf graf--li graf-after--li">You might also need to move the .kube/config folder to var/lib/jenkins</li><li name="aa33" id="aa33" class="graf graf--li graf-after--li">If you are using an insecure Docker registry, you’ll need to add the insecure-registry json in all the daemon.json files of the servers spawned by cloud formation</li></ul><h3 name="8ddb" id="8ddb" class="graf graf--h3 graf-after--li">Conclusion</h3><p name="f758" id="f758" class="graf graf--p graf-after--h3">That’s the complete process to create the Jenkins pipeline. This pipeline pulls the code from Bitbucket, tests it, installs it, creates a Docker image, pushes it to the Docker registry, and rolls out any updates. This process is useful because it drastically decreases code review time and testability improves due to smaller, specific changes. There is also an option to revert back to the previous deployment with the Kubernetes rollback option.</p><p name="596d" id="596d" class="graf graf--p graf-after--p graf--trailing">We used Jenkins in this example, but there are other tools such as Atlassian’s <a href="https://www.atlassian.com/software/bamboo" data-href="https://www.atlassian.com/software/bamboo" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Bamboo</a> or Netflix’s <a href="https://www.spinnaker.io/" data-href="https://www.spinnaker.io/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Spinnaker</a> which you can explore as well.</p></div></div></section>
</section>
</article></body></html>