<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Golang &amp; Angular Series — Part 1: Developing and Securing Golang APIs</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Golang &amp; Angular Series — Part 1: Developing and Securing Golang APIs</h1>
</header>
<section data-field="subtitle" class="p-summary">
A series that will show you how to develop modern applications with Golang and Angular.
</section>
<section data-field="body" class="e-content">
<section name="0f5f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0327" id="0327" class="graf graf--h3 graf--leading graf--title">Golang &amp; Angular Series — Part 1: Developing and Securing Golang APIs</h3><figure name="4026" id="4026" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 368px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 52.5%;"></div><img class="graf-image" data-image-id="1*xy9j8nCduDtufZzKowqbdA.png" data-width="1024" data-height="538" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*xy9j8nCduDtufZzKowqbdA.png"></div></figure><p name="bc28" id="bc28" class="graf graf--p graf-after--figure">A series that will show you how to develop modern applications with Golang and Angular.</p><h3 name="52d6" id="52d6" class="graf graf--h3 graf-after--p">Why Choose Golang and Angular</h3><p name="dd3a" id="dd3a" class="graf graf--p graf-after--h3">As mentioned, the technologies of choice for this series is <a href="https://golang.org/" data-href="https://golang.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Golang</a> for the backend and <a href="https://angular.io/" data-href="https://angular.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Angular</a> for the frontend. In this section, you will learn more about both platforms and why they are great options to develop applications nowadays.</p><h3 name="2da9" id="2da9" class="graf graf--h3 graf-after--p">Prerequisites</h3><p name="3df0" id="3df0" class="graf graf--p graf-after--h3">For this tutorial, you will need to install Golang, Node.js, and Angular. However, as you will see, the process is quite simple. For starters, you can visit <a href="https://golang.org/doc/install" data-href="https://golang.org/doc/install" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the official installation instructions provided by Golang</a> to install the programming language.</p><p name="5f25" id="5f25" class="graf graf--p graf-after--p">After that, you will need to install Node.js (which comes with NPM). For that, you can follow <a href="https://nodejs.org/en/download/" data-href="https://nodejs.org/en/download/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">the instructions described here</a>.</p><p name="c450" id="c450" class="graf graf--p graf-after--p">Then, after installing Node.js and NPM, you can issue the following command to install the <a href="https://cli.angular.io/" data-href="https://cli.angular.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Angular CLI</a> tool:</p><pre name="befb" id="befb" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">npm install -g @angular/cli</code></pre><blockquote name="d78f" id="d78f" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">Note: By adding </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">-g</em></code><em class="markup--em markup--blockquote-em"> in the command above, you make NPM install the Angular CLI tool globally. That is, after issuing this command, you will have the </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">ng</em></code><em class="markup--em markup--blockquote-em"> command in all new sessions of your terminal.</em></blockquote><h3 name="39bc" id="39bc" class="graf graf--h3 graf-after--blockquote">Building Backend APIs with Golang</h3><p name="b0b1" id="b0b1" class="graf graf--p graf-after--h3">In this section, you will learn how to build backend APIs with Golang. To facilitate your life, you will use <a href="https://github.com/gin-gonic/gin" data-href="https://github.com/gin-gonic/gin" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Gin</a>, an HTTP web framework written in Golang. Gin is, like many other frameworks, an open-source project that simplifies creating API endpoints.</p><p name="8a88" id="8a88" class="graf graf--p graf-after--p">What is good to keep in mind is that nothing that you will build in this article is impossible to do with the standard library of Golang. The only reason why you are using Gin is that it simplifies and standardizes the process a little, making your life easier.</p><h3 name="d8ac" id="d8ac" class="graf graf--h3 graf-after--p">Creating an In-Memory To-Do List with Golang</h3><p name="eec5" id="eec5" class="graf graf--p graf-after--h3">Before you start developing your web server, you will start writing the component that will handle the to-do list. To keep things simple, the implementation of this component will consist of a static object that will store all to-do items in-memory. Essentially, this component will work a very simple database (one that does not persist data to disk though).</p><p name="6e60" id="6e60" class="graf graf--p graf-after--p">Typically, this is not a bad way to start out the development process. Implementing a mock version of your database (before implementing your actual database) not only makes testing easier (and something that you can do from the beginning of your project) but it also helps to imply an interface for your store (or database).</p><p name="5465" id="5465" class="graf graf--p graf-after--p">Enough said, it’s time to get started with your backend API. Golang, by default, will look for packages in the <code class="markup--code markup--p-code">GO_PATH</code> environment variable. This variable usually refers to a place in the user directory (i.e., on Unix-like systems, this would be <code class="markup--code markup--p-code">~/go</code>, and on Windows, this would be <code class="markup--code markup--p-code">%USERPROFILE%/go</code>).</p><p name="84c6" id="84c6" class="graf graf--p graf-after--p">Packages are then stored in <code class="markup--code markup--p-code">$GO_PATH/src/</code> and, therefore, placing your projects there will make your life a lot easier. For this tutorial, you can place your Golang project in the <code class="markup--code markup--p-code">~/go/src/github.com/&lt;YOUR_GITHUB_USER&gt;/golang-angular</code> (you might have to create some of these directories). For the rest of the article, this directory will be referred to as the project root or simply <code class="markup--code markup--p-code">./</code>.</p><blockquote name="4bdd" id="4bdd" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Note: You will have to replace </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&lt;YOUR_GITHUB_USER&gt;</em></code><em class="markup--em markup--blockquote-em"> with your own GitHub username. That is, you do have a GitHub account, right?</em></blockquote><p name="da55" id="da55" class="graf graf--p graf-after--blockquote">So, in your project root (<code class="markup--code markup--p-code">./</code>), create a new directory called <code class="markup--code markup--p-code">todo</code>. Then, inside this directory, create a new file called <code class="markup--code markup--p-code">todo.go</code> with the following code:</p><pre name="273f" id="273f" class="graf graf--pre graf-after--p">package todo</pre><pre name="46c4" id="46c4" class="graf graf--pre graf-after--pre">import (<br>&quot;errors&quot;<br>&quot;sync&quot;<br>&quot;github.com/rs/xid&quot;<br>)</pre><pre name="48e4" id="48e4" class="graf graf--pre graf-after--pre">var (<br>list []Todo<br>mtx  sync.RWMutex<br>once sync.Once<br>)</pre><pre name="dc4d" id="dc4d" class="graf graf--pre graf-after--pre">func init() {</pre><pre name="ebd5" id="ebd5" class="graf graf--pre graf-after--pre">once.Do(initialiseList)</pre><pre name="0d33" id="0d33" class="graf graf--pre graf-after--pre">}</pre><pre name="e585" id="e585" class="graf graf--pre graf-after--pre">func initialiseList() {</pre><pre name="76a0" id="76a0" class="graf graf--pre graf-after--pre">list = []Todo{}</pre><pre name="48bc" id="48bc" class="graf graf--pre graf-after--pre">}</pre><pre name="5663" id="5663" class="graf graf--pre graf-after--pre">// Todo data structure for a task with a description of what to do</pre><pre name="a118" id="a118" class="graf graf--pre graf-after--pre">type Todo struct {<br>ID       string `json:&quot;id&quot;`<br>Message  string `json:&quot;message&quot;`<br>Complete bool   `json:&quot;complete&quot;`<br>}</pre><pre name="4a24" id="4a24" class="graf graf--pre graf-after--pre">// Get retrieves all elements from the todo list</pre><pre name="71d4" id="71d4" class="graf graf--pre graf-after--pre">func Get() []Todo {<br>return list<br>}</pre><pre name="8e93" id="8e93" class="graf graf--pre graf-after--pre">// Add will add a new todo based on a message</pre><pre name="71c1" id="71c1" class="graf graf--pre graf-after--pre">func Add(message string) string {<br>t := newTodo(message)<br>mtx.Lock()<br>list = append(list, t)<br>mtx.Unlock()<br>return t.ID<br>}</pre><pre name="4c31" id="4c31" class="graf graf--pre graf-after--pre">// Delete will remove a Todo from the Todo list</pre><pre name="2609" id="2609" class="graf graf--pre graf-after--pre">func Delete(id string) error {<br>location, err := findTodoLocation(id)<br>if err != nil {<br>return err<br>}</pre><pre name="5abd" id="5abd" class="graf graf--pre graf-after--pre">removeElementByLocation(location)<br>return nil<br>}</pre><pre name="4e99" id="4e99" class="graf graf--pre graf-after--pre">// Complete will set the complete boolean to true, marking a todo as<br>// completed</pre><pre name="6ece" id="6ece" class="graf graf--pre graf-after--pre">func Complete(id string) error {<br>location, err := findTodoLocation(id)</pre><pre name="0d44" id="0d44" class="graf graf--pre graf-after--pre">if err != nil {<br>return err<br>}</pre><pre name="b9d3" id="b9d3" class="graf graf--pre graf-after--pre">setTodoCompleteByLocation(location)<br>return nil</pre><pre name="be40" id="be40" class="graf graf--pre graf-after--pre">}</pre><pre name="9496" id="9496" class="graf graf--pre graf-after--pre">func newTodo(msg string) Todo {</pre><pre name="b36c" id="b36c" class="graf graf--pre graf-after--pre">return Todo{<br>ID:       xid.New().String(),<br>Message:  msg,<br>Complete: false,</pre><pre name="001e" id="001e" class="graf graf--pre graf-after--pre">}</pre><pre name="1a65" id="1a65" class="graf graf--pre graf-after--pre">}<br>func findTodoLocation(id string) (int, error) {</pre><pre name="9c72" id="9c72" class="graf graf--pre graf-after--pre">mtx.RLock()<br>defer mtx.RUnlock()<br>for i, t := range list {<br>if isMatchingID(t.ID, id) {<br>return i, nil<br>}</pre><pre name="3db9" id="3db9" class="graf graf--pre graf-after--pre">}<br>return 0, errors.New(&quot;could not find todo based on id&quot;)</pre><pre name="2905" id="2905" class="graf graf--pre graf-after--pre">}</pre><pre name="091b" id="091b" class="graf graf--pre graf-after--pre">func removeElementByLocation(i int) {<br>mtx.Lock()<br>list = append(list[:i], list[i+1:]...)<br>mtx.Unlock()</pre><pre name="3aa2" id="3aa2" class="graf graf--pre graf-after--pre">}</pre><pre name="ff0e" id="ff0e" class="graf graf--pre graf-after--pre">func setTodoCompleteByLocation(location int) {<br>mtx.Lock()<br>list[location].Complete = true<br>mtx.Unlock()<br>}</pre><pre name="58c4" id="58c4" class="graf graf--pre graf-after--pre">func isMatchingID(a string, b string) bool {<br>return a == b</pre><pre name="ee09" id="ee09" class="graf graf--pre graf-after--pre">}</pre><p name="aebf" id="aebf" class="graf graf--p graf-after--pre">In the very top of the bottom (right after defining the package and importing a few other packages), you will find the variables that will be globally-available in this file:</p><ul class="postList"><li name="29e2" id="29e2" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">list</code>: This is the array that will hold all to-do items.</li><li name="b1df" id="b1df" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">mtx</code>: This is the <a href="https://gobyexample.com/mutexes" data-href="https://gobyexample.com/mutexes" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">mutex</a> that will allow you to safely access/manipulate the data in this package across different <a href="https://gobyexample.com/goroutines" data-href="https://gobyexample.com/goroutines" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">goroutines</em></a>.</li><li name="4a9a" id="4a9a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">once</code>: This is a Golang native functionality (<code class="markup--code markup--li-code"><a href="https://golang.org/pkg/sync/#Once" data-href="https://golang.org/pkg/sync/#Once" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">sync.Once</a></code>), which will help you assure that a specific operation will run only once.</li></ul><p name="3bd8" id="3bd8" class="graf graf--p graf-after--li">After the declaration of these variables, you will find the <code class="markup--code markup--p-code">init</code> function and you will see that it runs another function called <code class="markup--code markup--p-code">initialiseList</code>. The latter is responsible for initializing the array of to-do items but will ensure that this initialization will run only once. As Golang runs the <code class="markup--code markup--p-code">init</code> function whenever the package is initialized (i.e., whenever the package is loaded), you needed to wrap the <code class="markup--code markup--p-code">initialiseList</code> function inside <code class="markup--code markup--p-code">once.Do</code>. In this way, you avoid resetting the array on the runtime.</p><p name="0ddc" id="0ddc" class="graf graf--p graf-after--p">Then, after these two functions that initialize the package, you will find the <code class="markup--code markup--p-code">Todo</code> structure. This struct defines that to-do items will have an <code class="markup--code markup--p-code">ID</code>, a <code class="markup--code markup--p-code">Message</code> and whether the todo item is <code class="markup--code markup--p-code">Complete</code> or not. Also, while defining this struct, you are also mapping all properties of your struct into its JSON equivalent. This is a very useful feature in Golang and, if needed, <a href="https://blog.golang.org/json-and-go" data-href="https://blog.golang.org/json-and-go" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">you can find more info about it here</a>. As the naming convention in Golang defines that all properties starting with a capital letter are public and all starting with a small letter are private in a struct, this mapping also helps you ensure you can stick with the naming conventions available in JSON.</p><blockquote name="576d" id="576d" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Note: If you were to define other packages that would use this struct, it would be a good idea to place it in another package for itself. However, for this simple application, placing it here will suffice.</em></blockquote><p name="5cb0" id="5cb0" class="graf graf--p graf-after--blockquote">Right after the definition of the <code class="markup--code markup--p-code">Todo</code> struct, you will find the first method of your to-do store: <code class="markup--code markup--p-code">Get</code>. This method starts with a capital letter and, therefore, is public (meaning it can be accessed by other packages). The <code class="markup--code markup--p-code">Get</code> method implementation is very simple, it simply returns your current static to-do list (the global <code class="markup--code markup--p-code">list</code> variable).</p><p name="5ff7" id="5ff7" class="graf graf--p graf-after--p">Then, below this method, you will find the <code class="markup--code markup--p-code">Add</code> method, which will create a new to-do (based on a user input message) and append to the global <code class="markup--code markup--p-code">list</code>. Notice that you are using your <code class="markup--code markup--p-code">mutex</code> to <code class="markup--code markup--p-code">Lock</code> before you append new items to your list and then <code class="markup--code markup--p-code">Unlock</code> again once the operation ends. As your server might handle multiple operations at the same time, this is a <em class="markup--em markup--p-em">very</em> important step. If these operations try to access the same memory, you can run into a race-condition that might make Golang crash. To avoid this, you are using <code class="markup--code markup--p-code">mutex</code>, which is scoped to your package.</p><p name="7ce6" id="7ce6" class="graf graf--p graf-after--p">After <code class="markup--code markup--p-code">Add</code>, you will find the last two public functions. First, you will find <code class="markup--code markup--p-code">Delete</code>, which, as the name states, will remove an item from the <code class="markup--code markup--p-code">list</code>. Then, you will find <code class="markup--code markup--p-code">Complete</code>, which will mark a to-do item as complete (based on its <code class="markup--code markup--p-code">ID</code>) in your <code class="markup--code markup--p-code">list</code>.</p><p name="aad4" id="aad4" class="graf graf--p graf-after--p">Then, after the public functions, you will find the private functions of your package. For starter, you will find the <code class="markup--code markup--p-code">newTodo</code> function, which will take in a <code class="markup--code markup--p-code">msg</code> in the form of a <code class="markup--code markup--p-code">string</code> and return a new instance of the <code class="markup--code markup--p-code">Todo</code> struct. This instance will contain an <code class="markup--code markup--p-code">ID</code> (i.e., a UUID in the form of a string) and the <code class="markup--code markup--p-code">complete</code> flag set to false.</p><p name="5f23" id="5f23" class="graf graf--p graf-after--p">The next private function you will find is the <code class="markup--code markup--p-code">findTodoLocation</code> function. You will use this function to find the index location of a to-do item based on its <code class="markup--code markup--p-code">ID</code>. If no matches are found after iterating over all the items, this function will return an error saying that it couldn&#39;t find the desired item. Notice that you are using <code class="markup--code markup--p-code">mutex</code> again in this method. This time, you are using the <code class="markup--code markup--p-code">RLock</code> (Read Lock) function since you will only be reading from your list and not writing to it.</p><p name="5389" id="5389" class="graf graf--p graf-after--p">Right after the <code class="markup--code markup--p-code">findTodoLocation</code> function, you will see the <code class="markup--code markup--p-code">removeElementByLocation</code> function. In this function, you are setting your <code class="markup--code markup--p-code">list</code> variable to a new array, which contains all elements from the previous <code class="markup--code markup--p-code">list</code> up to a given location, appended with all elements after (but not including) the same given location. This means that, by giving a specific location to this function, you will get a new list without that given location (essentially deleting it from the previous list).</p><p name="cf30" id="cf30" class="graf graf--p graf-after--p">Then, the very last function in your store package is <code class="markup--code markup--p-code">setTodoCompleteByLocation</code>. Just like your remove function, this function takes in a location in the form of an integer. However, this function is much less complex and simply sets the <code class="markup--code markup--p-code">Complete</code> property of the item found on the given location to true.</p><p name="ead1" id="ead1" class="graf graf--p graf-after--p">Lastly, if you take a close look at the source code of this package, you will notice that it is using a third-party package called <code class="markup--code markup--p-code">xid</code> for generating UUIDs (Universally Unique Identifiers). As such, you will need to obtain this package before compiling your application. To do so, you will have to run the following command:</p><pre name="fbc7" id="fbc7" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">go get github.com/rs/xid</code></pre><h3 name="81e7" id="81e7" class="graf graf--h3 graf-after--pre">Building the Golang Web Server and Serving Static Files</h3><p name="8fca" id="8fca" class="graf graf--p graf-after--h3">Right on! Now is the time to develop a web server with Golang and Gin. So, for starters, you will need to grab Gin from the internet. To do this, run the following code:</p><pre name="92ee" id="92ee" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">go get github.com/gin-gonic/gin</code></pre><p name="3a42" id="3a42" class="graf graf--p graf-after--pre">Great. Now, in your project root (<code class="markup--code markup--p-code">./</code>), you will create a file called <code class="markup--code markup--p-code">main.go</code> and insert the following code into it:</p><pre name="fe85" id="fe85" class="graf graf--pre graf-after--p">package main</pre><pre name="16e3" id="16e3" class="graf graf--pre graf-after--pre">func main() {<br>r := gin.Default()<br>r.NoRoute(func(c *gin.Context) {<br>dir, file := path.Split(c.Request.RequestURI)ext := filepath.Ext(file)<br>if file == &quot;&quot; || ext == &quot;&quot; {<br>c.File(&quot;./ui/dist/ui/index.html&quot;)<br>} else {<br>c.File(&quot;./ui/dist/ui/&quot; + path.Join(dir, file))</pre><pre name="6b41" id="6b41" class="graf graf--pre graf-after--pre">}</pre><pre name="fc96" id="fc96" class="graf graf--pre graf-after--pre">})</pre><pre name="98ba" id="98ba" class="graf graf--pre graf-after--pre">r.GET(&quot;/todo&quot;, handlers.GetTodoListHandler)<br>r.POST(&quot;/todo&quot;, handlers.AddTodoHandler)<br>r.DELETE(&quot;/todo/:id&quot;, handlers.DeleteTodoHandler)<br>r.PUT(&quot;/todo&quot;, handlers.CompleteTodoHandler)</pre><pre name="f381" id="f381" class="graf graf--pre graf-after--pre">err := r.Run(&quot;:3000&quot;)</pre><pre name="f292" id="f292" class="graf graf--pre graf-after--pre">if err != nil {<br>panic(err)<br>}</pre><pre name="0be4" id="0be4" class="graf graf--pre graf-after--pre">}</pre><p name="1aee" id="1aee" class="graf graf--p graf-after--pre">Compared to the package you built in the last section, this file is pretty straightforward. First, you create your Gin server using <code class="markup--code markup--p-code">gin.Default()</code>. This command will return an object that you can use to configure and run the web server.</p><p name="8fbd" id="8fbd" class="graf graf--p graf-after--p">Then, you do something that can be considered a little bit <em class="markup--em markup--p-em">hacky</em>. As you may know, routing in Gin is quite specific and cannot have ambiguous routes for the root path. Essentially, Gin will complain if you have a configuration like <code class="markup--code markup--p-code">/*</code> because this will interfere with every other route in your web server (those would never be called). In Node.js (and other popular web servers), you can do this because the path routing is determined by the most specific to the least specific configuration. So, in that case, a route like <code class="markup--code markup--p-code">/api/something</code> would have precedence over <code class="markup--code markup--p-code">/*</code>.</p><p name="ecf2" id="ecf2" class="graf graf--p graf-after--p">Unfortunately, this is not the case by default in Gin. However, to implement this in your server, you will take advantage of the <code class="markup--code markup--p-code">NoRoute</code> function, which matches all routes that have not been specified already. This route function will assume that this call is asking for a file and attempt to find this file.</p><p name="58df" id="58df" class="graf graf--p graf-after--p">If a client asks for the root path, or if the file is not found, you will serve them the <code class="markup--code markup--p-code">index.html</code>file (which will be produced from your Angular project at a later point). Otherwise, you will serve the file requested by the client.</p><blockquote name="1043" id="1043" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Note: There are other ways to do this and, depending on what you want to achieve, better ways to achieve that. However, for this tutorial, this will do just fine.</em></blockquote><p name="3182" id="3182" class="graf graf--p graf-after--blockquote">Now, after this generic endpoint, you are adding routes to fetch the data from your to-do list. They are all pointing to the same path ‘/todo’, but they all use different HTTP methods:</p><ul class="postList"><li name="1279" id="1279" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">GET</code>: This endpoint enables users to retrieve the entire to-do list.</li><li name="d651" id="d651" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">POST</code>: This endpoint enables users to add new items to the list.</li><li name="70f7" id="70f7" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">DELETE</code>: This endpoint enables users to delete a to-do from the list based on an <code class="markup--code markup--li-code">ID</code>.</li><li name="b0a6" id="b0a6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">PUT</code>: This endpoint enables users to change a to-do item from incomplete to complete.</li></ul><p name="e6da" id="e6da" class="graf graf--p graf-after--li">Each one of these endpoints is structured in the same manner (i.e., <code class="markup--code markup--p-code">r.&lt;METHOD&gt;(&lt;PATH&gt;, &lt;Gin function&gt;)</code>. Your Gin function is basically any function that takes the parameter of a <code class="markup--code markup--p-code">gin.Context</code> pointer. If you look at the <code class="markup--code markup--p-code">NoRoute</code> function, you will see an example of an anonymous function with the input of a <code class="markup--code markup--p-code">gin.Context</code> pointer.</p><p name="deb1" id="deb1" class="graf graf--p graf-after--p">Lastly, the <code class="markup--code markup--p-code">main.go</code> script runs your web server on port <code class="markup--code markup--p-code">3000</code> and <code class="markup--code markup--p-code">panic</code> if an error occurs while running the web server.</p><p name="aa9c" id="aa9c" class="graf graf--p graf-after--p">In the next section, you will learn how to develop the handlers that will manage the incoming HTTP requests.</p><h3 name="c06c" id="c06c" class="graf graf--h3 graf-after--p">Developing the API Endpoints with Gin Handlers</h3><p name="cd1b" id="cd1b" class="graf graf--p graf-after--h3">To handle the incoming HTTP requests, in this section, you will learn how to develop Gin handlers. To begin with, you will create a new directory called <code class="markup--code markup--p-code">handlers</code> in the project root. Then, inside this directory, you will create a file called <code class="markup--code markup--p-code">handlers.go</code>. In this file, you will write the code necessary to handle all methods (<code class="markup--code markup--p-code">GET</code>, <code class="markup--code markup--p-code">POST</code>, <code class="markup--code markup--p-code">PUT</code>, and <code class="markup--code markup--p-code">DELETE</code>) available in your API endpoints (<code class="markup--code markup--p-code">/todo</code>).</p><p name="cd98" id="cd98" class="graf graf--p graf-after--p">Since you already implemented most of the functionality necessary in the <code class="markup--code markup--p-code">todo</code> package, this will be a relatively simple exercise. The final code in the <code class="markup--code markup--p-code">handlers.go</code> file will look as such:</p><pre name="e933" id="e933" class="graf graf--pre graf-after--p">package handlers</pre><pre name="7564" id="7564" class="graf graf--pre graf-after--pre">import (<br>&quot;encoding/json&quot;<br>&quot;io&quot;<br>&quot;io/ioutil&quot;<br>&quot;net/http&quot;<br>&quot;github.com/&lt;YOUR_GITHUB_USER&gt;/golang-auth0-example/todo&quot;<br>&quot;github.com/gin-gonic/gin&quot;<br>)<br>// GetTodoListHandler returns all current todo items</pre><pre name="7384" id="7384" class="graf graf--pre graf-after--pre">func GetTodoListHandler(c *gin.Context) {<br>c.JSON(http.StatusOK, todo.Get())<br>}</pre><pre name="7774" id="7774" class="graf graf--pre graf-after--pre">// AddTodoHandler adds a new todo to the todo list</pre><pre name="b0db" id="b0db" class="graf graf--pre graf-after--pre">func AddTodoHandler(c *gin.Context) {<br>todoItem, statusCode, err := convertHTTPBodyToTodo(c.Request.Body)<br>if err != nil {<br>c.JSON(statusCode, err)<br>return<br>}<br>c.JSON(statusCode, gin.H{&quot;id&quot;: todo.Add(todoItem.Message)})<br>}</pre><pre name="c975" id="c975" class="graf graf--pre graf-after--pre">// DeleteTodoHandler will delete a specified todo based on user http input<br>func DeleteTodoHandler(c *gin.Context) {<br>todoID := c.Param(&quot;id&quot;)<br>if err := todo.Delete(todoID); err != nil {<br>c.JSON(http.StatusInternalServerError, err)<br>return<br>}<br>c.JSON(http.StatusOK, &quot;&quot;)<br>}</pre><pre name="a3f1" id="a3f1" class="graf graf--pre graf-after--pre">// CompleteTodoHandler will complete a specified todo based on user http input<br>func CompleteTodoHandler(c *gin.Context) {<br>todoItem, statusCode, err := convertHTTPBodyToTodo(c.Request.Body)<br>if err != nil {<br>c.JSON(statusCode, err)<br>return<br>}</pre><pre name="bfbc" id="bfbc" class="graf graf--pre graf-after--pre">if todo.Complete(todoItem.ID) != nil {<br>c.JSON(http.StatusInternalServerError, err)<br>return<br>}<br>c.JSON(http.StatusOK, &quot;&quot;)<br>}</pre><pre name="4fa9" id="4fa9" class="graf graf--pre graf-after--pre">func convertHTTPBodyToTodo(httpBody io.ReadCloser) (todo.Todo, int, error) {<br>body, err := ioutil.ReadAll(httpBody)<br>if err != nil {<br>return todo.Todo{}, http.StatusInternalServerError, err</pre><pre name="2a26" id="2a26" class="graf graf--pre graf-after--pre">}<br>defer httpBody.Close()<br>return convertJSONBodyToTodo(body)<br>}<br>func convertJSONBodyToTodo(jsonBody []byte) (todo.Todo, int, error) {<br>var todoItem todo.Todo<br>err := json.Unmarshal(jsonBody, &amp;todoItem)<br>if err != nil {<br>return todo.Todo{}, http.StatusBadRequest, err<br>}<br>return todoItem, http.StatusOK, nil</pre><pre name="7fc7" id="7fc7" class="graf graf--pre graf-after--pre">}</pre><blockquote name="a768" id="a768" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">Note: You will have to replace </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&lt;YOUR_GITHUB_USER&gt;</em></code><em class="markup--em markup--blockquote-em"> in the code above with your own GitHub username.</em></blockquote><p name="d71f" id="d71f" class="graf graf--p graf-after--blockquote">As mentioned earlier, all of your handler functions take a pointer to <code class="markup--code markup--p-code">gin.Context</code> as a parameter. This parameter essentially contains the <code class="markup--code markup--p-code">http.Request</code> reader and an <code class="markup--code markup--p-code">http.ResponseWriter</code> writer. Besides these functionalities that allow you to read from the request and to write a response, this pointer contains a lot of metadata about the request.</p><p name="7058" id="7058" class="graf graf--p graf-after--p">Basically speaking, this code is structured as follows:</p><ol class="postList"><li name="d450" id="d450" class="graf graf--li graf-after--p">Grab input and convert if necessary.</li><li name="b4bd" id="b4bd" class="graf graf--li graf-after--li">Check for errors.</li><li name="13f1" id="13f1" class="graf graf--li graf-after--li">Perform operation.</li><li name="544c" id="544c" class="graf graf--li graf-after--li">Return <code class="markup--code markup--li-code">error</code> or the <code class="markup--code markup--li-code">ok</code> status.</li></ol><p name="f4fa" id="f4fa" class="graf graf--p graf-after--li">At the bottom of the code, you will notice two helper functions specifically tailored to parse input. The <code class="markup--code markup--p-code">convertHTTPBodyToTodo</code> function will read the body from the request and return it as a <code class="markup--code markup--p-code">Todo</code> object. This is done by using the <code class="markup--code markup--p-code">ioutil.ReadAll</code> which will read all bytes from an <code class="markup--code markup--p-code">io.Reader</code> stream. Once this function reads all bytes, you use <code class="markup--code markup--p-code">convertJSONBodyToTodo</code> to convert them from JSON (which is the original format of the request body) to a <code class="markup--code markup--p-code">Todo</code> object.</p><p name="bb2e" id="bb2e" class="graf graf--p graf-after--p">With these convert operations encapsulated in their functions, it’s pretty easy to keep your handlers logic simple and neat. The only other thing that might be worth mentioning the usage of the <code class="markup--code markup--p-code">c.JSON</code> function. You are using this function to convert the response into JSON objects before sending them to your users.</p><p name="d474" id="d474" class="graf graf--p graf-after--p">After these changes, you are ready to run your Golang API. So, go to your project root and issue the following command:</p><pre name="545d" id="545d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">go run main.go</code></pre><p name="6d68" id="6d68" class="graf graf--p graf-after--pre">This will make your server start listening requests on <code class="markup--code markup--p-code">localhost:3000</code>. To test it, you can then use a command-line tool like <code class="markup--code markup--p-code">curl</code> or a graphical solution like <a href="https://www.getpostman.com/" data-href="https://www.getpostman.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Postman</a>. Using <code class="markup--code markup--p-code">curl</code>, you can test your application like this:</p><pre name="a9fd" id="a9fd" class="graf graf--pre graf-after--p"># add a new to-do item</pre><pre name="459d" id="459d" class="graf graf--pre graf-after--pre">curl localhost:3000/todo -d &#39;{&quot;message&quot;: &quot;finish writing the article&quot;}&#39;</pre><pre name="9f58" id="9f58" class="graf graf--pre graf-after--pre"># get all to-do items</pre><pre name="9131" id="9131" class="graf graf--pre graf-after--pre">curl localhost:3000/todo</pre><figure name="4c7c" id="4c7c" class="graf graf--figure graf-after--pre"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 276px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 39.5%;"></div><img class="graf-image" data-image-id="1*5MxLYUzlUWuEMIgFxIdysw.jpeg" data-width="892" data-height="352" src="https://cdn-images-1.medium.com/max/800/1*5MxLYUzlUWuEMIgFxIdysw.jpeg"></div></figure><h3 name="08bf" id="08bf" class="graf graf--h3 graf-after--figure">Securing the Golang API with Auth0</h3><p name="b69e" id="b69e" class="graf graf--p graf-after--h3">That’s awesome. You now have a Golang backend API up and running. Time to celebrate? Not quite yet… you have one big issue. Right now, anyone can issue requests to your API. That’s not ideal. You probably want to make sure that only people that you trust can access and edit your to-do list. To do this, you will use <a href="https://auth0.com/learn/cloud-identity-access-management/" data-href="https://auth0.com/learn/cloud-identity-access-management/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Auth0 as the Identity and Access Management (IAM) system</a> of your service.</p><p name="0abc" id="0abc" class="graf graf--p graf-after--p">If you don’t have an Auth0 account yet, you can <a href="https://auth0.com/signup" data-href="https://auth0.com/signup" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">sign up for a free one here</a>.</p><p name="d8cf" id="d8cf" class="graf graf--p graf-after--p">After signing up for Auth0, you will have to go to your <a href="https://manage.auth0.com/" data-href="https://manage.auth0.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Auth0 dashboard</a> and proceed as follows:</p><ol class="postList"><li name="a116" id="a116" class="graf graf--li graf-after--p">go to <a href="https://manage.auth0.com/#/apis" data-href="https://manage.auth0.com/#/apis" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">the <em class="markup--em markup--li-em">APIs</em> section</a>;</li><li name="fb1e" id="fb1e" class="graf graf--li graf-after--li">click on <em class="markup--em markup--li-em">Create API</em>;</li><li name="65c3" id="65c3" class="graf graf--li graf-after--li">define a <em class="markup--em markup--li-em">Name</em> for your API (e.g., “Golang API”);</li><li name="6bbf" id="6bbf" class="graf graf--li graf-after--li">define an <em class="markup--em markup--li-em">Identifier</em> for it (e.g., <code class="markup--code markup--li-code"><a href="https://my-golang-api%29;" data-href="https://my-golang-api);" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://my-golang-api</a></code><a href="https://my-golang-api%29;" data-href="https://my-golang-api);" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">);</a></li><li name="5b20" id="5b20" class="graf graf--li graf-after--li">and click on the <em class="markup--em markup--li-em">Create</em> button (leave the <em class="markup--em markup--li-em">Signing Algorithm</em> with RS256).</li></ol><figure name="33b1" id="33b1" class="graf graf--figure graf-after--li"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 528px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 75.4%;"></div><img class="graf-image" data-image-id="1*GY0wfBkGeN-xkgt13_aJ-g.jpeg" data-width="924" data-height="697" src="https://cdn-images-1.medium.com/max/800/1*GY0wfBkGeN-xkgt13_aJ-g.jpeg"></div></figure><p name="f053" id="f053" class="graf graf--p graf-after--figure">In a second or two, Auth0 will redirect you to your new Auth0 API. For this article, you won’t have to change any other configuration on Auth0’s dashboard. However, you can leave it open as you will have to copy a few values from it soon.</p><p name="113a" id="113a" class="graf graf--p graf-after--p">So, back in your code, you will want to refactor your API to check if the requests arriving have <a href="https://auth0.com/docs/tokens/access-token" data-href="https://auth0.com/docs/tokens/access-token" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">access tokens</a> issued by Auth0. To do this, open your <code class="markup--code markup--p-code">main.go</code> file and replace its code with this:</p><pre name="4772" id="4772" class="graf graf--pre graf-after--p">package main</pre><pre name="f8e0" id="f8e0" class="graf graf--pre graf-after--pre">import (<br>&quot;log&quot;<br>&quot;net/http&quot;<br>&quot;os&quot;<br>&quot;path&quot;<br>&quot;path/filepath&quot;<br>&quot;github.com/auth0-community/go-auth0&quot;<br>&quot;github.com/gin-gonic/gin&quot;<br>jose &quot;gopkg.in/square/go-jose.v2&quot;<br>&quot;github.com/&lt;YOUR_GITHUB_USER&gt;/golang-auth0-example/handlers&quot;<br>)</pre><pre name="5b0b" id="5b0b" class="graf graf--pre graf-after--pre">var (<br>audience string<br>domain   string<br>)</pre><pre name="43bd" id="43bd" class="graf graf--pre graf-after--pre">func main() {<br>setAuth0Variables()<br>r := gin.Default()</pre><pre name="9287" id="9287" class="graf graf--pre graf-after--pre">// This will ensure that the angular files are served correctly<br>r.NoRoute(func(c *gin.Context) {<br>dir, file := path.Split(c.Request.RequestURI)<br>ext := filepath.Ext(file)<br>if file == &quot;&quot; || ext == &quot;&quot; {<br>c.File(&quot;./ui/dist/ui/index.html&quot;)</pre><pre name="3eb9" id="3eb9" class="graf graf--pre graf-after--pre">} else {<br>c.File(&quot;./ui/dist/ui/&quot; + path.Join(dir, file))<br>}<br>})</pre><pre name="0e18" id="0e18" class="graf graf--pre graf-after--pre">authorized := r.Group(&quot;/&quot;)<br>authorized.Use(authRequired())<br>authorized.GET(&quot;/todo&quot;, handlers.GetTodoListHandler)<br>authorized.POST(&quot;/todo&quot;, handlers.AddTodoHandler)<br>authorized.DELETE(&quot;/todo/:id&quot;, handlers.DeleteTodoHandler)<br>authorized.PUT(&quot;/todo&quot;, handlers.CompleteTodoHandler)<br>err := r.Run(&quot;:3000&quot;)</pre><pre name="6403" id="6403" class="graf graf--pre graf-after--pre">if err != nil {<br>panic(err)<br>}<br>}</pre><pre name="4b6b" id="4b6b" class="graf graf--pre graf-after--pre"><br>func setAuth0Variables() {</pre><pre name="8b4c" id="8b4c" class="graf graf--pre graf-after--pre">audience = os.Getenv(&quot;AUTH0_API_IDENTIFIER&quot;)<br>domain = os.Getenv(&quot;AUTH0_DOMAIN&quot;)</pre><pre name="62c3" id="62c3" class="graf graf--pre graf-after--pre">}</pre><pre name="0949" id="0949" class="graf graf--pre graf-after--pre">// ValidateRequest will verify that a token received from an http request<br>// is valid and signyed by Auth0</pre><pre name="36ec" id="36ec" class="graf graf--pre graf-after--pre">func authRequired() gin.HandlerFunc {<br>return func(c *gin.Context) {</pre><pre name="e12e" id="e12e" class="graf graf--pre graf-after--pre">var auth0Domain = &quot;https://&quot; + domain + &quot;/&quot;</pre><pre name="ec86" id="ec86" class="graf graf--pre graf-after--pre">client := auth0.NewJWKClient(auth0.JWKClientOptions{URI: auth0Domain + &quot;.well-known/jwks.json&quot;}, nil)</pre><pre name="21c8" id="21c8" class="graf graf--pre graf-after--pre">configuration := auth0.NewConfiguration(client, []string{audience}, auth0Domain, jose.RS256)</pre><pre name="82e1" id="82e1" class="graf graf--pre graf-after--pre">validator := auth0.NewValidator(configuration, nil)</pre><pre name="e1b7" id="e1b7" class="graf graf--pre graf-after--pre">_, err := validator.ValidateRequest(c.Request)</pre><pre name="1050" id="1050" class="graf graf--pre graf-after--pre">if err != nil {<br>log.Println(err)<br>terminateWithError(http.StatusUnauthorized, &quot;token is not valid&quot;, c)<br>return</pre><pre name="98c3" id="98c3" class="graf graf--pre graf-after--pre">}<br>c.Next()<br>}</pre><pre name="e0f1" id="e0f1" class="graf graf--pre graf-after--pre">}</pre><pre name="90fc" id="90fc" class="graf graf--pre graf-after--pre">func terminateWithError(statusCode int, message string, c *gin.Context) {</pre><pre name="a390" id="a390" class="graf graf--pre graf-after--pre">c.JSON(statusCode, gin.H{&quot;error&quot;: message})<br>c.Abort()<br>}</pre><blockquote name="fb68" id="fb68" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">Note: You will have to replace </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&lt;YOUR_GITHUB_USER&gt;</em></code><em class="markup--em markup--blockquote-em"> in the code above with your own GitHub username.</em></blockquote><p name="f2ee" id="f2ee" class="graf graf--p graf-after--blockquote">If you analyze the new version of this code carefully, you will notice that you added a routing group (called <code class="markup--code markup--p-code">authorized</code>) to secure all endpoints in your backend. That is, by calling <code class="markup--code markup--p-code">authorized.Use(authRequired())</code> and putting all endpoint definitions inside the <code class="markup--code markup--p-code">authorized</code> routing group, you are telling Gin that all requests made to these endpoints must be evaluated by the <code class="markup--code markup--p-code">authRequired</code> function first.</p><p name="c2ed" id="c2ed" class="graf graf--p graf-after--p">Another change in this code is the addition of two new global variables: <code class="markup--code markup--p-code">audience</code> and <code class="markup--code markup--p-code">domain</code>. You need these variables so you can validate access tokens against Auth0. As you can see, these variables will be retrieved from your environment variables on start, using the <code class="markup--code markup--p-code">setAuth0Variables</code> function. You will set them with your Auth0 values before running your backend again.</p><p name="6388" id="6388" class="graf graf--p graf-after--p">As the core piece of validation is the <code class="markup--code markup--p-code">authRequired</code> function, a better explanation about it is required. The <code class="markup--code markup--p-code">authRequired</code> function is what is known as a middleware function. In Gin terms, a middleware must return a <code class="markup--code markup--p-code">gin.HandlerFunc</code> function that contains a call to <code class="markup--code markup--p-code">Next()</code> in the body. Basically, your function validates a token, which is found in the <code class="markup--code markup--p-code">Authorization</code> header of the incoming request. The middleware does this by using JWKS (JSON Web Key Set). Essentially, <a href="https://auth0.com/docs/jwks" data-href="https://auth0.com/docs/jwks" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">JWKS is a method for verifying JWT, using a public/private key infrastructure</a>.</p><p name="5394" id="5394" class="graf graf--p graf-after--p">Luckily for you, using Auth0’s Golang library makes this process extremely simple. All you have to do is to write a few lines of code to validate the incoming token. If this results in an error, you terminate the current connection, responding to it with an <code class="markup--code markup--p-code">http.StatusUnauthorized</code> (401) status. If the token is valid, then you send the request onto the next function (by calling <code class="markup--code markup--p-code">Next()</code>) in the handler chain.</p><p name="b48a" id="b48a" class="graf graf--p graf-after--p">Before wrapping up, you still need to install the two new libraries that this code is now using:</p><pre name="01a0" id="01a0" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">go get github.com/auth0-community/go-auth0 gopkg.in/square/go-jose.v2</code></pre><p name="327a" id="327a" class="graf graf--p graf-after--pre">That’s it. Securing a Golang backend API with Auth0 is as simple as that. To see this in action, hit <code class="markup--code markup--p-code">Ctrl</code> + <code class="markup--code markup--p-code">c</code> to stop the previously running instance of your API and then run it again:</p><pre name="10e5" id="10e5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code"># set env variables<br>export AUTH0_API_IDENTIFIER=&lt;YOUR_AUTH0_API&gt;<br>export AUTH0_DOMAIN=&lt;YOUR_AUTH0_TENANT&gt;.auth0.com</code></pre><pre name="4590" id="4590" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">go run main.go</code></pre><blockquote name="1d21" id="1d21" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">Note: You have to replace </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&lt;YOUR_AUTH0_API&gt;</em></code><em class="markup--em markup--blockquote-em"> with the identifier you set in your Auth0 API while creating it. Also, you have to replace </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">&lt;YOUR_AUTH0_TENANT&gt;</em></code><em class="markup--em markup--blockquote-em"> with the subdomain you chose while creating your Auth0 account.</em></blockquote><p name="a8be" id="a8be" class="graf graf--p graf-after--blockquote">Now, if you try to issue a request to your API without sending an access token retrieved from Auth0:</p><pre name="c19b" id="c19b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">curl GET localhost:3000/todo</code></pre><p name="684d" id="684d" class="graf graf--p graf-after--pre">You will get a nice error sent back:</p><pre name="6aeb" id="6aeb" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">{<br>  &quot;error&quot;:&quot;token is not valid&quot;<br>}</code></pre><p name="8f90" id="8f90" class="graf graf--p graf-after--pre">To fetch a temporary access token to validate that your server still works, you can go to the <em class="markup--em markup--p-em">Test</em> section of your Auth0 API and copy the <code class="markup--code markup--p-code">curl</code> command shown there.</p><figure name="9914" id="9914" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 396px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.599999999999994%;"></div><img class="graf-image" data-image-id="1*MnSsFCncirohFRuHqzl5qA.jpeg" data-width="951" data-height="538" src="https://cdn-images-1.medium.com/max/800/1*MnSsFCncirohFRuHqzl5qA.jpeg"></div></figure><p name="73bc" id="73bc" class="graf graf--p graf-after--figure">Executing this <code class="markup--code markup--p-code">curl</code> command will make Auth0 generate an access token that you can use to communicate with your backend API.</p><figure name="ad62" id="ad62" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 384px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 54.900000000000006%;"></div><img class="graf-image" data-image-id="1*H0PZ4eQZX8FB_AUwVK2EKA.jpeg" data-width="887" data-height="487" src="https://cdn-images-1.medium.com/max/800/1*H0PZ4eQZX8FB_AUwVK2EKA.jpeg"></div></figure><p name="baa1" id="baa1" class="graf graf--p graf-after--figure">To facilitate issuing requests to your backend, you can copy the access token generated and save it in an environment variable:</p><pre name="79b9" id="79b9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">ACCESS_TOKEN=&quot;eyJ0eX...WXaTRg&quot;</code></pre><p name="1e5f" id="1e5f" class="graf graf--p graf-after--pre">After that, you can issue authenticated requests like this:</p><pre name="bef8" id="bef8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code"># authenticated req to add a new to-do item<br>curl -H &#39;Authorization: Bearer &#39;$ACCESS_TOKEN localhost:3000/todo -d &#39;{&quot;message&quot;: &quot;finish writing the article&quot;}&#39;</code></pre><pre name="7816" id="7816" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code"># authenticated req to get all to-do items<br>curl -H &#39;Authorization: Bearer &#39;$ACCESS_TOKEN localhost:3000/todo</code></pre><h3 name="cd3b" id="cd3b" class="graf graf--h3 graf-after--pre">Conclusion and Next Steps</h3><p name="910f" id="910f" class="graf graf--p graf-after--h3">Done! You just finished developing a secure backend API with Golang, Gin, and Auth0. The application that you created was pretty simple, just a todo list where you can add, delete, and to-do items as complete. However, the framework around your application is quite sound. You handled authentication via Auth0, which creates a very strong starting point for your application (it is important to think about security and identity management from the start).</p><p name="11f1" id="11f1" class="graf graf--p graf-after--p">Adding features to your application now becomes a lot easier. Once you have established a strong fundament in security, you can add different to-do lists for different users. Using a third-party security solution like Auth0 is also a great advantage because you can rest assured that this solution will keep your users’ personal data safe. With a few changes here and there (such as serving your API and static files over HTTPS), you can quite confidently deploy this code to production.</p><p name="05bd" id="05bd" class="graf graf--p graf-after--p">I hope the first part of this series has been helpful and that it has given some insight on how easy it is to implement Auth0 as a third-party authentication service on Golang. In the second part of this series, The Front-end-Developing and Securing Angular Apps, you will learn how to implement the frontend client of your to-do list with Angular and how to integrate it with your Golang backend API.</p><p name="003e" id="003e" class="graf graf--p graf-after--p graf--trailing">Stay tuned!</p></div></div></section>
</section>
</article></body></html>