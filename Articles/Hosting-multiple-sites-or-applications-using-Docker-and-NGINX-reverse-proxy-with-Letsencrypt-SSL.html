<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Hosting multiple sites or applications using Docker and NGINX reverse proxy with Letsencrypt SSL</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Hosting multiple sites or applications using Docker and NGINX reverse proxy with Letsencrypt SSL</h1>
</header>
<section data-field="subtitle" class="p-summary">
n this article, you’ll find instructions for how to setup multiple websites with SSL on one host easily using Docker, Docker Compose…
</section>
<section data-field="body" class="e-content">
<section name="be1b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="57ad" id="57ad" class="graf graf--h3 graf--leading graf--title">Hosting multiple sites or applications using Docker and NGINX reverse proxy with Letsencrypt SSL</h3><p name="9634" id="9634" class="graf graf--p graf-after--h3">In this article, you’ll find instructions for how to set up multiple websites with SSL on one host easily using <a href="https://www.docker.com/" data-href="https://www.docker.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Docker</a>, <a href="https://docs.docker.com/compose/" data-href="https://docs.docker.com/compose/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Docker Compose</a>, <a href="https://www.nginx.com/" data-href="https://www.nginx.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">nginx</a>, and <a href="https://letsencrypt.org/" data-href="https://letsencrypt.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Let’s Encrypt</a>.</p><figure name="c603" id="c603" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 397px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 56.699999999999996%;"></div><img class="graf-image" data-image-id="1*qgDUTXtHTA79GQYeUDwmoA.png" data-width="1800" data-height="1020" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*qgDUTXtHTA79GQYeUDwmoA.png"></div></figure><h3 name="1c93" id="1c93" class="graf graf--h3 graf-after--figure">Nginx proxy</h3><p name="cb78" id="cb78" class="graf graf--p graf-after--h3">To be able to host multiple websites on one machine we need a proxy server that will handle all requests and direct them to the correct nginx server instances running in Docker containers. To achieve that we will use <a href="https://github.com/jwilder/nginx-proxy" data-href="https://github.com/jwilder/nginx-proxy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">jwilder/nginx-proxy</a> image for Docker. It will automatically configure a proxy for our nginx containers when we launch them.</p><p name="f381" id="f381" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">nginx-proxy</code> has a couple things happening:</p><ul class="postList"><li name="c057" id="c057" class="graf graf--li graf-after--p">Its ports 80 and 443 are forwarded to the host, making it Internet-facing. No other containers we run on this machine will need their ports forwarded, all communication from and to the outside will be proxied through here — hence “reverse proxy”.</li><li name="9a99" id="9a99" class="graf graf--li graf-after--li">Various NGINX configuration directories are mounted as named volumes to keep them persistent on the host system. Those volumes are defined further down in the file.</li><li name="bac4" id="bac4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">/var/run/docker.sock</code> from the host is mounted. This allows the proxy to listen in to other containers starting and stopping on the host, and configure NGINX forwarding as needed. Containers need to present their desired hostnames and ports as environment variables that the proxy can read - more on that further below.</li><li name="a086" id="a086" class="graf graf--li graf-after--li">Finally, the container is assigned to a <code class="markup--code markup--li-code">proxy</code> external network, which is described below.</li></ul><h3 name="efd3" id="efd3" class="graf graf--h3 graf-after--li">NGINX reverse proxy and SSL</h3><p name="933a" id="933a" class="graf graf--p graf-after--h3">The NGINX reverse proxy is the key to this whole setup. Its job is to listen on external ports 80 and 443 and connect requests to corresponding Docker containers, without exposing their inner workings or ports directly to the outside world. Additionally, with the SSL companion container the proxy also automatically redirects all HTTP requests to HTTPS and handles SSL encryption for all traffic, including certificate management.</p><figure name="94e2" id="94e2" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 683px; max-height: 321px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 47%;"></div><img class="graf-image" data-image-id="1*icFg8qm101mEateXl56xXA.png" data-width="683" data-height="321" src="https://cdn-images-1.medium.com/max/800/1*icFg8qm101mEateXl56xXA.png"></div></figure><h3 name="fe04" id="fe04" class="graf graf--h3 graf-after--figure">Let’s Encrypt companion</h3><p name="cfdd" id="cfdd" class="graf graf--p graf-after--h3">For automatic certificate management, we will use <a href="https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion" data-href="https://github.com/JrCs/docker-letsencrypt-nginx-proxy-companion" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">jrcs/letsencrypt-nginx-proxy-companion</a> image. It will watch for containers that we launch and do everything needed along with the nginx proxy to enable SSL on our nginx virtual host containers.</p><p name="847c" id="847c" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">letsencrypt</code> is a companion container to <code class="markup--code markup--p-code">nginx-proxy</code> that handles all the necessary SSL tasks - obtaining the required certificates from Let’s Encrypt and keeping them up-to-date, and auto-configuring <code class="markup--code markup--p-code">nginx-proxy</code> to transparently encrypt all proxied traffic to and from application containers.</p><p name="589b" id="589b" class="graf graf--p graf-after--p">It’s connected to <code class="markup--code markup--p-code">nginx-proxy</code> by sharing its volumes (<code class="markup--code markup--p-code">volumes-from:</code> directive). It also listens in on the host’s <code class="markup--code markup--p-code">/var/run/docker.sock</code> to be notified when application containers are started and to get the information from them to obtain the necessary SSL certificates.</p><p name="3500" id="3500" class="graf graf--p graf-after--p">Note that this container doesn’t need to be put in the external network — it gets by only using the shared volumes and Docker socket, and never needs to talk to the outside world or another container directly.</p><h4 name="63b8" id="63b8" class="graf graf--h4 graf-after--p">External network</h4><p name="ce2e" id="ce2e" class="graf graf--p graf-after--h4">Last but not least, there’s the external network. To understand why you might need it, you need to know how docker-compose handles networks by default:</p><ul class="postList"><li name="790c" id="790c" class="graf graf--li graf-after--p">For every application that is run using its own <code class="markup--code markup--li-code">docker-compose.yml</code>, Compose creates a separate network. All containers within that application are assigned only to that network and can talk to each other and to the Internet.</li><li name="b7ce" id="b7ce" class="graf graf--li graf-after--li">We want to deploy multiple applications on this server using Compose, each with their own, and proxy them all to the outside world via our <code class="markup--code markup--li-code">nginx-proxy</code> container.</li><li name="b0b3" id="b0b3" class="graf graf--li graf-after--li">No other container can access containers within a default network created by docker-compose, only those inside the application’s own <code class="markup--code markup--li-code">docker-compose.yml</code>. This makes life difficult for <code class="markup--code markup--li-code">nginx-proxy</code>.</li><li name="9ed1" id="9ed1" class="graf graf--li graf-after--li">To work around this, we create a single network outside of Compose’s infrastructure and place our <code class="markup--code markup--li-code">nginx-proxy</code> container in that network. To do this, we need to define this network as <code class="markup--code markup--li-code">external</code> in the <code class="markup--code markup--li-code">docker-compose.yml</code> - this way Compose will not try to create the network itself, but just assign the containers it creates to the existing outside network.</li><li name="3b39" id="3b39" class="graf graf--li graf-after--li">If we try to run this as it is, Compose will error out telling us the external network doesn’t exist.</li></ul><p name="e216" id="e216" class="graf graf--p graf-after--li">We need to initially create the proxy network manually with:</p><pre name="c4fa" id="c4fa" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">sudo docker network create nginx-proxy</code></pre><p name="fef8" id="fef8" class="graf graf--p graf-after--pre">Now we can run our proxy container and SSL companion:</p><pre name="5bf9" id="5bf9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">sudo docker-compose up -d</code></pre><p name="656b" id="656b" class="graf graf--p graf-after--pre">And continue with deploying at least one application behind the proxy to see that it actually works.</p><h3 name="3ae0" id="3ae0" class="graf graf--h3 graf-after--p">Main Docker Compose file</h3><p name="2959" id="2959" class="graf graf--p graf-after--h3">Let’s start by creating our main Docker Compose file, that will launch our nginx proxy and Let’s Encrypt companion containers. In a separate folder called <em class="markup--em markup--p-em">proxy</em> create file <em class="markup--em markup--p-em">docker-compose.yml</em> with contents below:</p><pre name="535e" id="535e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">version: &#39;3&#39; # Version of the Docker Compose file format<br>services:<br>    nginx-proxy:<br>        image: jwilder/nginx-proxy:alpine<br>        restart: &quot;always&quot; # Always restart container<br>        ports:<br>         - &quot;80:80&quot; # Port mappings in format host:container<br>         - &quot;443:443&quot;<br>        networks:<br>         - nginx-proxy # Name of the etwork these two containers will share<br>        labels:<br>         - &quot;com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy&quot; # Label needed for Let&#39;s Encrypt companion container<br>        volumes: # Volumes needed for container to configure proixes and access certificates genereated by Let&#39;s Encrypt companion container<br>         - /var/run/docker.sock:/tmp/docker.sock:ro<br>         - &quot;nginx-conf:/etc/nginx/conf.d&quot;<br>         - &quot;nginx-vhost:/etc/nginx/vhost.d&quot;<br>         - &quot;html:/usr/share/nginx/html&quot;<br>         - &quot;certs:/etc/nginx/certs:ro&quot;<br>    letsencrypt-nginx-proxy-companion:<br>        image: jrcs/letsencrypt-nginx-proxy-companion<br>        restart: always<br>        container_name: letsencrypt-nginx-proxy-companion<br>        volumes:<br>         - &quot;/var/run/docker.sock:/var/run/docker.sock:ro&quot;<br>         - &quot;nginx-conf:/etc/nginx/conf.d&quot;<br>         - &quot;nginx-vhost:/etc/nginx/vhost.d&quot;<br>         - &quot;html:/usr/share/nginx/html&quot;<br>         - &quot;certs:/etc/nginx/certs:rw&quot;<br>        depends_on: # Make sure we start nginx proxy container first<br>            - nginx-proxy<br>networks:<br>    nginx-proxy: # Name of our shared network that containers will use<br>volumes: # Names of volumes that out containers will share. Those will persist on docker&#39;s host machine.<br>    nginx-conf:<br>    nginx-vhost:<br>    html:<br>    certs:</code>COPY</pre><p name="75a0" id="75a0" class="graf graf--p graf-after--pre">Now, if we’ll execute the following command:</p><pre name="24c4" id="24c4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker-compose up -d</code></pre><p name="9817" id="9817" class="graf graf--p graf-after--pre">Docker Compose will look for a file named <em class="markup--em markup--p-em">docker-compose.yml</em> in the current folder and launch all services (containers) that are described in there. In this case it will launch nginx proxy and Let’s Encrypt companion containers. Also, because we trying to launch it for the first time it will build images first.</p><p name="8570" id="8570" class="graf graf--p graf-after--p">Flag -d means that we want to run our containers in the background (detached mode).</p><p name="432d" id="432d" class="graf graf--p graf-after--p">Use the following command to check containers status:</p><pre name="05b4" id="05b4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker ps</code></pre><p name="01a3" id="01a3" class="graf graf--p graf-after--pre">You should see two containers with Up status.</p><h3 name="8251" id="8251" class="graf graf--h3 graf-after--p">Nginx virtual host</h3><p name="1f82" id="1f82" class="graf graf--p graf-after--h3">Now, we will launch our first nginx container that will securely serve content through the proxy to the client.</p><p name="f439" id="f439" class="graf graf--p graf-after--p">In a new folder, called <em class="markup--em markup--p-em">example.com</em> (replace with the name of your domain) create a new <em class="markup--em markup--p-em">docker-compose.yml</em> file. In a subfolder named <em class="markup--em markup--p-em">www</em> place contents of your website. Also, create a subfolder called <em class="markup--em markup--p-em">nginx</em> with two files called <em class="markup--em markup--p-em">Dockerfile</em> and <em class="markup--em markup--p-em">default.conf</em>.</p><p name="c861" id="c861" class="graf graf--p graf-after--p">Structure of <em class="markup--em markup--p-em">example.com</em> folder should look like this:</p><ul class="postList"><li name="0958" id="0958" class="graf graf--li graf-after--p">www folder with your website’s content</li><li name="5f46" id="5f46" class="graf graf--li graf-after--li">index.html</li><li name="1e9d" id="1e9d" class="graf graf--li graf-after--li">etc…</li></ul><p name="afef" id="afef" class="graf graf--p graf-after--li">==============</p><ul class="postList"><li name="d502" id="d502" class="graf graf--li graf-after--p">nginx</li><li name="8ff1" id="8ff1" class="graf graf--li graf-after--li">Dockerfile</li><li name="0317" id="0317" class="graf graf--li graf-after--li">default.conf</li></ul><p name="5509" id="5509" class="graf graf--p graf-after--li">==============</p><ul class="postList"><li name="bb72" id="bb72" class="graf graf--li graf-after--p">docker-compose.yml</li></ul><p name="03fe" id="03fe" class="graf graf--p graf-after--li">Dockerfile:</p><pre name="897c" id="897c" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--pre-strong">FROM</strong> nginx:alpine<br><strong class="markup--strong markup--pre-strong">COPY</strong> ./nginx/default.conf /etc/nginx/conf.d/default.conf # Copy nginx configuration file<br><strong class="markup--strong markup--pre-strong">COPY</strong> ./www/ /usr/share/nginx/html/ # Copy website contents</code>COPY</pre><p name="8c38" id="8c38" class="graf graf--p graf-after--pre">default.conf:</p><pre name="2f56" id="2f56" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--pre-strong">server</strong> {<br>	<strong class="markup--strong markup--pre-strong">listen</strong> 80 default_server;<br>	<strong class="markup--strong markup--pre-strong">listen</strong> 443 ssl;</code></pre><pre name="5e3e" id="5e3e" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">	<strong class="markup--strong markup--pre-strong">server_name</strong> example.com;</code></pre><pre name="fbbf" id="fbbf" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">	<strong class="markup--strong markup--pre-strong">root</strong> /usr/share/nginx/html/;<br>	<strong class="markup--strong markup--pre-strong">index</strong> index.html;</code></pre><pre name="3d6a" id="3d6a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0">	<strong class="markup--strong markup--pre-strong">location</strong> / {<br>		<strong class="markup--strong markup--pre-strong">try_files</strong> $uri $uri/ =404;<br>	}<br>}</code>COPY</pre><p name="4391" id="4391" class="graf graf--p graf-after--pre">docker-compose.yml:</p><pre name="0a18" id="0a18" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">version: &#39;3&#39;<br>services:<br>    nginx:<br>        container_name: example-nginx<br>        image: example-nginx<br>        restart: always<br>        build:<br>            context: ./<br>            dockerfile: ./nginx/Dockerfile<br>        environment:<br>         - VIRTUAL_HOST=example.com # Enviroment variable needed for nginx proxy<br>         - LETSENCRYPT_HOST=example.com # Enviroment variables needed for Let&#39;s Encrypt companion<br>         - LETSENCRYPT_EMAIL=admin@example.com<br>        expose:<br>         - &quot;80&quot; # Expose http port<br>         - &quot;443&quot; # along with https port<br>        networks:<br>         - nginx-proxy # Connect this container to network named nginx-proxy, that will be described below<br>networks:<br>    nginx-proxy:<br>        external:<br>            name: proxy_nginx-proxy # Reference our network that was created by Docker Compose when we launched our two main containers earlier. Name generated automaticaly. Use `docker network ls` to list all networks and their names.</code>COPY</pre><p name="6b32" id="6b32" class="graf graf--p graf-after--pre">Don’t forget to replace <em class="markup--em markup--p-em">example.com</em> in all files with your domain name.</p><p name="54b8" id="54b8" class="graf graf--p graf-after--p">Now everything ready for building and launching our container:</p><pre name="c911" id="c911" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker-compose up -d</code></pre><p name="86fb" id="86fb" class="graf graf--p graf-after--pre">Now you have three up and running Docker containers: nginx proxy for handling requests and configuring proxies for our virtual hosts, Let’s Encrypt companion for generating SSL certificates and one virtual host container that will serve to users content.</p><h3 name="fba9" id="fba9" class="graf graf--h3 graf-after--p">Multi-container applications</h3><p name="b94e" id="b94e" class="graf graf--p graf-after--h3">Most applications you might want to deploy consist of several containers — say, a database, a backend service that does some processing, and a frontend. Of those containers, you may only want the frontend to be accessible from the outside, but the three should be able to talk to each other internally. A <code class="markup--code markup--p-code">docker-compose.yml</code> for such a setup might look something like:</p><pre name="e0e2" id="e0e2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">version: &#39;3&#39;</code></pre><pre name="edcc" id="edcc" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">services:</code></pre><pre name="2a5c" id="2a5c" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  frontend:<br>    image: frontend-image:latest<br>    expose:<br>      - &quot;3000&quot;<br>    environment:<br>      - VIRTUAL_HOST=awesomeapp.domain.tld<br>      - VIRTUAL_PORT=3000<br>      - LETSENCRYPT_HOST=awesomeapp.domain.tld<br>      - LETSENCRYPT_EMAIL=email@somewhere.tld<br>      - BACKEND_HOST=backend<br>    networks:<br>      - proxy<br>      - app</code></pre><pre name="c5cd" id="c5cd" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  backend:<br>    image: backend-image:latest<br>    environment:<br>      - DB_HOST=db<br>    networks:<br>      - app</code></pre><pre name="15aa" id="15aa" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">  db:<br>    image: postgres:11<br>    volumes:<br>      - /opt/app-db:/var/lib/postgresql/data<br>    networks:<br>      - app</code></pre><pre name="b0c4" id="b0c4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">networks:<br>  proxy:<br>    external:<br>      name: nginx-proxy<br>  app:</code></pre><p name="b25c" id="b25c" class="graf graf--p graf-after--pre">Things of note here:</p><ul class="postList"><li name="2d9d" id="2d9d" class="graf graf--li graf-after--p">Only the <code class="markup--code markup--li-code">frontend</code> container is put into the <code class="markup--code markup--li-code">proxy</code> external network because it’s the only one that needs to talk to <code class="markup--code markup--li-code">nginx-proxy</code>. It’s also the only one with the environment variables for proxy configuration. The containers that are only used internally in the app don’t need those</li><li name="acd4" id="acd4" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">backend</code> and <code class="markup--code markup--li-code">db</code> containers are put in a separate <code class="markup--code markup--li-code">app</code> network, that is defined additionally under <code class="markup--code markup--li-code">networks</code>. This serves in place of a default network that Compose would normally create for all containers defined in the <code class="markup--code markup--li-code">docker-compose.yml</code> - except once you define any network manually, the default network doesn’t get created anymore, and so our <code class="markup--code markup--li-code">backend</code> and <code class="markup--code markup--li-code">db</code> containers would be completely isolated. With the <code class="markup--code markup--li-code">app</code> network, they can talk to each other and to <code class="markup--code markup--li-code">frontend</code> normally.</li></ul><p name="540d" id="540d" class="graf graf--p graf-after--li">As you can see, the setup is not very complicated. The only things to add to your normal <code class="markup--code markup--p-code">docker-compose.yml</code> of any multi-container app are the networks and environment variables for the frontend container.</p><h4 name="ebec" id="ebec" class="graf graf--h4 graf-after--p">Multiple proxied frontend containers</h4><p name="03ef" id="03ef" class="graf graf--p graf-after--h4">You can have multiple containers within a single Compose application that you want to make available via the proxy — for example, a public frontend and an administrative back office. You can configure as many containers inside one <code class="markup--code markup--p-code">docker-compose.yml</code> with the <code class="markup--code markup--p-code">proxy</code> network and necessary environment variables as you need. The only limitation is that every container needs to run on a separate <code class="markup--code markup--p-code">VIRTUAL_HOST</code>.</p><p name="c888" id="c888" class="graf graf--p graf-after--p">For example, you could run your public frontend at <code class="markup--code markup--p-code">awesomeapp.domain.tld</code> and the admin backend to that at <code class="markup--code markup--p-code">admin.awesomeapp.domain.tld</code>.</p><h3 name="ea37" id="ea37" class="graf graf--h3 graf-after--p">That’s it!</h3><p name="f08d" id="f08d" class="graf graf--p graf-after--h3">In no time you’ll be able to access your website securely!<br>To launch another virtual host, just repeat steps starting from <strong class="markup--strong markup--p-strong">Nginx Virtual Host</strong> paragraph.</p><h3 name="057b" id="057b" class="graf graf--h3 graf-after--p">Rebuilding the container’s image</h3><p name="0d9a" id="0d9a" class="graf graf--p graf-after--h3">To rebuild docker images described in compose file, for example, if you changed the website’s content, use the following command:</p><pre name="a3e2" id="a3e2" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker-compose build</code></pre><p name="894b" id="894b" class="graf graf--p graf-after--pre">It will rebuild all images of services that are described in <em class="markup--em markup--p-em">docker-compose.yml</em> file located in the current folder.</p><h3 name="f30e" id="f30e" class="graf graf--h3 graf-after--p">What if something isn’t working</h3><p name="e000" id="e000" class="graf graf--p graf-after--h3">If you have problems launching containers, try to launch them without -d flag, this way you’ll be able to see the output of the container’s service (its <em class="markup--em markup--p-em">stdout</em> and <em class="markup--em markup--p-em">stderr</em>).</p><p name="b38d" id="b38d" class="graf graf--p graf-after--p">To see logs of already running container you can use the following command:</p><pre name="51d1" id="51d1" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker logs CONTAINER_ID</code></pre><p name="31de" id="31de" class="graf graf--p graf-after--pre">To find CONTAINER_ID look at the output of the following command:</p><pre name="eef4" id="eef4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">docker ps</code></pre><h3 name="73d3" id="73d3" class="graf graf--h3 graf-after--pre">SNI</h3><p name="35c0" id="35c0" class="graf graf--p graf-after--h3">The ability to serve content from different domains using different certificates from one host is possible thanks to SNI. You can read more about this technology on <a href="https://en.wikipedia.org/wiki/Server_Name_Indication" data-href="https://en.wikipedia.org/wiki/Server_Name_Indication" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Wikipedia</a>. It’s widely supported technology in browsers and other web clients. You can check support by popular web browsers <a href="http://caniuse.com/#feat=sni" data-href="http://caniuse.com/#feat=sni" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><h3 name="bc35" id="bc35" class="graf graf--h3 graf-after--p">Github project</h3><p name="c02d" id="c02d" class="graf graf--p graf-after--h3 graf--trailing">You can find an example project on<a href="https://github.com/DimuthuKasunWP/docker-nginx-letsencrypt-example" data-href="https://github.com/DimuthuKasunWP/docker-nginx-letsencrypt-example" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> GitHub</a>. Have fun!</p></div></div></section>
</section>
</article></body></html>